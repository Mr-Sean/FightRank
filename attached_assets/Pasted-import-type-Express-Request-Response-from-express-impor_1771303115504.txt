import type { Express, Request, Response } from "express";
import { createServer, type Server } from "http";
import { db } from "@db";
import { setupAuth } from "./auth";
import { eq, and, desc, sql } from "drizzle-orm";
import { events, fights, ratings, comments, users } from "@db/schema";

// Middleware to check if user is authenticated
const isAuthenticated = (req: Request, res: Response, next: Function) => {
  if (req.isAuthenticated()) {
    return next();
  }
  res.status(401).send("Authentication required");
};

export function registerRoutes(app: Express): Server {
  // Set up authentication routes first
  setupAuth(app);

  // Basic health check
  app.get("/api/health", (_req, res) => {
    res.json({ status: "ok" });
  });

  // Events routes
  // GET all events:
  app.get("/api/events", async (_req, res) => {
    try {
      const allEvents = await db
        .select()
        .from(events)
        .orderBy(desc(events.date));
      res.json(allEvents);
    } catch (error) {
      console.error("Failed to fetch events:", error);
      res.status(500).send("Failed to fetch events");
    }
  });

  // POST create event:
  app.post("/api/events", isAuthenticated, async (req, res) => {
    try {
      const { title, promotion, date } = req.body;
      const [newEvent] = await db
        .insert(events)
        .values({
          title,
          promotion,
          date: new Date(date),
        })
        .returning();
      res.json(newEvent);
    } catch (error) {
      console.error("Failed to create event:", error);
      res.status(500).send("Failed to create event");
    }
  });

  // PUT update event:
  app.put("/api/events/:id", isAuthenticated, async (req, res) => {
    try {
      const eventId = parseInt(req.params.id);
      const { title, promotion, date } = req.body;
      const [updatedEvent] = await db
        .update(events)
        .set({ title, promotion, date: new Date(date) })
        .where(eq(events.id, eventId))
        .returning();
      res.json(updatedEvent);
    } catch (error) {
      console.error("Failed to update event:", error);
      res.status(500).send("Failed to update event");
    }
  });

  // DELETE event (deletes the event and all its fights, ratings, and comments):
  app.delete("/api/events/:id", isAuthenticated, async (req, res) => {
    try {
      const eventId = parseInt(req.params.id);
      await db.transaction(async (tx) => {
        const eventFights = await tx
          .select({ id: fights.id })
          .from(fights)
          .where(eq(fights.eventId, eventId));

        const fightIds = eventFights.map(f => f.id);

        if (fightIds.length > 0) {
          for (const fightId of fightIds) {
            await tx.delete(ratings).where(eq(ratings.fightId, fightId));
            await tx.delete(comments).where(eq(comments.fightId, fightId));
          }
          await tx.delete(fights).where(eq(fights.eventId, eventId));
        }

        await tx.delete(events).where(eq(events.id, eventId));
      });
      res.json({ message: "Event and associated data deleted successfully" });
    } catch (error) {
      console.error("Failed to delete event:", error);
      res.status(500).send("Failed to delete event");
    }
  });

  // Get fights for a specific event (add new route):
  app.get("/api/events/:id/fights", async (req, res) => {
    try {
      const eventId = parseInt(req.params.id);
      const userId = req.user?.id;

      const fightsWithRatings = await db
        .select({
          id: fights.id,
          eventId: fights.eventId,
          fighter1: fights.fighter1,
          fighter2: fights.fighter2,
          averageRating: sql<number>`COALESCE(AVG(${ratings.rating}), 0)`,
          userRating: sql<number | null>`
            MAX(CASE 
              WHEN ${ratings.userId} = ${userId} THEN ${ratings.rating}
              ELSE NULL 
            END)
          `,
        })
        .from(fights)
        .leftJoin(ratings, eq(fights.id, ratings.fightId))
        .where(eq(fights.eventId, eventId))
        .groupBy(fights.id, fights.eventId, fights.fighter1, fights.fighter2);

      res.json(fightsWithRatings);
    } catch (error) {
      console.error("Failed to fetch fights:", error);
      res.status(500).send("Failed to fetch fights");
    }
  });