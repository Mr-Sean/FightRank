import type { Express, Request, Response } from "express";
import { createServer, type Server } from "http";
import { db } from "@db";
import { setupAuth } from "./auth";
import { eq, and, desc, sql } from "drizzle-orm";
import { events, fights, ratings, comments, users } from "@db/schema";

// Middleware to check if user is authenticated
const isAuthenticated = (req: Request, res: Response, next: Function) => {
  if (req.isAuthenticated()) {
    return next();
  }
  res.status(401).send("Authentication required");
};

export function registerRoutes(app: Express): Server {
  // Set up authentication routes first
  setupAuth(app);

  // Basic health check
  app.get("/api/health", (_req, res) => {
    res.json({ status: "ok" });
  });

  // Events routes
  // GET all events:
  app.get("/api/events", async (_req, res) => {
    try {
      const allEvents = await db
        .select()
        .from(events)
        .orderBy(desc(events.date));
      res.json(allEvents);
    } catch (error) {
      console.error("Failed to fetch events:", error);
      res.status(500).send("Failed to fetch events");
    }
  });

  // POST create event:
  app.post("/api/events", isAuthenticated, async (req, res) => {
    try {
      const { title, promotion, date } = req.body;
      const [newEvent] = await db
        .insert(events)
        .values({
          title,
          promotion,
          date: new Date(date),
        })
        .returning();
      res.json(newEvent);
    } catch (error) {
      console.error("Failed to create event:", error);
      res.status(500).send("Failed to create event");
    }
  });

  // PUT update event:
  app.put("/api/events/:id", isAuthenticated, async (req, res) => {
    try {
      const eventId = parseInt(req.params.id);
      const { title, promotion, date } = req.body;
      const [updatedEvent] = await db
        .update(events)
        .set({ title, promotion, date: new Date(date) })
        .where(eq(events.id, eventId))
        .returning();
      res.json(updatedEvent);
    } catch (error) {
      console.error("Failed to update event:", error);
      res.status(500).send("Failed to update event");
    }
  });

  // DELETE event (deletes the event and all its fights, ratings, and comments):
  app.delete("/api/events/:id", isAuthenticated, async (req, res) => {
    try {
      const eventId = parseInt(req.params.id);
      await db.transaction(async (tx) => {
        const eventFights = await tx
          .select({ id: fights.id })
          .from(fights)
          .where(eq(fights.eventId, eventId));

        const fightIds = eventFights.map(f => f.id);

        if (fightIds.length > 0) {
          for (const fightId of fightIds) {
            await tx.delete(ratings).where(eq(ratings.fightId, fightId));
            await tx.delete(comments).where(eq(comments.fightId, fightId));
          }
          await tx.delete(fights).where(eq(fights.eventId, eventId));
        }

        await tx.delete(events).where(eq(events.id, eventId));
      });
      res.json({ message: "Event and associated data deleted successfully" });
    } catch (error) {
      console.error("Failed to delete event:", error);
      res.status(500).send("Failed to delete event");
    }
  });

  // Get fights for a specific event (add new route):
  app.get("/api/events/:id/fights", async (req, res) => {
    try {
      const eventId = parseInt(req.params.id);
      const userId = req.user?.id;

      const fightsWithRatings = await db
        .select({
          id: fights.id,
          eventId: fights.eventId,
          fighter1: fights.fighter1,
          fighter2: fights.fighter2,
          averageRating: sql<number>`COALESCE(AVG(${ratings.rating}), 0)`,
          userRating: sql<number | null>`
            MAX(CASE 
              WHEN ${ratings.userId} = ${userId} THEN ${ratings.rating}
              ELSE NULL 
            END)
          `,
        })
        .from(fights)
        .leftJoin(ratings, eq(fights.id, ratings.fightId))
        .where(eq(fights.eventId, eventId))
        .groupBy(fights.id, fights.eventId, fights.fighter1, fights.fighter2);

      res.json(fightsWithRatings);
    } catch (error) {
      console.error("Failed to fetch fights:", error);
      res.status(500).send("Failed to fetch fights");
    }
  });
  
  // Fights routes
  app.put("/api/fights/:id", isAuthenticated, async (req, res) => {
    try {
      const { fighter1, fighter2 } = req.body;
      const fightId = parseInt(req.params.id);
      
      const [updatedFight] = await db
        .update(fights)
        .set({
          fighter1,
          fighter2,
        })
        .where(eq(fights.id, fightId))
        .returning();
      
      res.json(updatedFight);
    } catch (error) {
      console.error("Failed to update fight:", error);
      res.status(500).send("Failed to update fight");
    }
  });

  app.post("/api/fights", isAuthenticated, async (req, res) => {
    try {
      const { eventId, fighter1, fighter2 } = req.body;
      const [newFight] = await db
        .insert(fights)
        .values({
          eventId,
          fighter1,
          fighter2,
        })
        .returning();
      res.json(newFight);
    } catch (error) {
      console.error("Failed to create fight:", error);
      res.status(500).send("Failed to create fight");
    }
  });

  // Get comments for a specific fight
  app.get("/api/fights/:id/comments", async (req, res) => {
    try {
      const fightId = parseInt(req.params.id);
      const fightComments = await db
        .select({
          id: comments.id,
          content: comments.content,
          createdAt: comments.createdAt,
          userId: comments.userId,
          username: users.username,
        })
        .from(comments)
        .leftJoin(users, eq(comments.userId, users.id))
        .where(eq(comments.fightId, fightId))
        .orderBy(comments.createdAt);

      res.json(fightComments);
    } catch (error) {
      console.error("Failed to fetch comments:", error);
      res.status(500).send("Failed to fetch comments");
    }
  });

  // Create a new comment
  app.post("/api/comments", isAuthenticated, async (req, res) => {
    try {
      const { fightId, content } = req.body;
      const userId = req.user!.id;

      const [newComment] = await db
        .insert(comments)
        .values({
          userId,
          fightId,
          content,
        })
        .returning();

      res.json(newComment);
    } catch (error) {
      console.error("Failed to create comment:", error);
      res.status(500).send("Failed to create comment");
    }
  });

  // Ratings routes
  app.post("/api/ratings", isAuthenticated, async (req, res) => {
    try {
      const { fightId, rating } = req.body;
      const userId = req.user!.id;

      // Update or create rating
      const [result] = await db
        .insert(ratings)
        .values({ userId, fightId, rating })
        .onConflictDoUpdate({
          target: [ratings.userId, ratings.fightId],
          set: { rating },
        })
        .returning();

      res.json(result);
    } catch (error) {
      console.error("Failed to submit rating:", error);
      res.status(500).send("Failed to submit rating");
    }
  });

  // Add delete route for fights
  app.delete("/api/fights/:id", isAuthenticated, async (req, res) => {
    try {
      const fightId = parseInt(req.params.id);

      // Start a transaction to ensure data consistency
      await db.transaction(async (tx) => {
        // Delete associated ratings first
        await tx
          .delete(ratings)
          .where(eq(ratings.fightId, fightId));

        // Delete associated comments
        await tx
          .delete(comments)
          .where(eq(comments.fightId, fightId));

        // Delete the fight
        const [deletedFight] = await tx
          .delete(fights)
          .where(eq(fights.id, fightId))
          .returning();

        if (!deletedFight) {
          throw new Error("Fight not found");
        }
      });

      res.json({ message: "Fight and associated data deleted successfully" });
    } catch (error) {
      console.error("Failed to delete fight:", error);
      res.status(500).send("Failed to delete fight");
    }
  });

  const httpServer = createServer(app);
  return httpServer;
}